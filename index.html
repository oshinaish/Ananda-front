<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#4A90E2">
    
    <title>Restaurant Cost Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px;
            border-radius: 50%; border-left-color: #4A90E2;
            animation: spin 1s ease infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #toast {
            visibility: hidden; min-width: 250px; background-color: #333; color: #fff;
            text-align: center; border-radius: 2px; padding: 16px; position: fixed;
            z-index: 1; left: 50%; transform: translateX(-50%); bottom: 30px;
            opacity: 0; transition: opacity 0.5s, visibility 0.5s;
        }
        #toast.show { visibility: visible; opacity: 1; }
        /* Style for the editable table */
        .editable-table-container { max-height: 300px; overflow-y: auto; }
        .editable-table th, .editable-table td { padding: 8px 12px; border: 1px solid #e2e8f0; text-align: left; }
        .editable-table th { background-color: #f8fafc; font-weight: bold; }
        /* UPDATED: Added background color to inputs for better visibility */
        .editable-table input { width: 100%; border: 1px solid #cbd5e1; padding: 4px; border-radius: 4px; background-color: #f7fafc;}
        .editable-table input:focus { outline: 2px solid #4A90E2; }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

    <div class="bg-white p-6 rounded-lg shadow-lg max-w-lg w-full text-center">
        <!-- Main Home Screen -->
        <div id="homeScreen">
            <h1 class="text-2xl font-bold mb-2">Restaurant Cost Tracker üçΩÔ∏è</h1>
            <p class="text-gray-600 mb-6">Select an image to process</p>
            <div class="space-y-4">
                <button onclick="showImageSourceDialog('Upload Store Demand for Sec-23', 'StoreDemand-23')" class="w-full bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center space-x-2 transition-transform transform hover:scale-105"><span>Store Demand for Sec-23</span></button>
                <button onclick="showImageSourceDialog('Upload Store Demand for Sec-31', 'StoreDemand-31')" class="w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center space-x-2 transition-transform transform hover:scale-105"><span>Store Demand for Sec-31</span></button>
                <button onclick="showImageSourceDialog('Upload Purchase Invoice for Base Kitchen', 'Purchases-Base Kitchen')" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center space-x-2 transition-transform transform hover:scale-105"><span>Purchase Invoice - Base Kitchen</span></button>
                <button onclick="showImageSourceDialog('Upload Inventory Out- Base Kitchen', 'Inventory-Base Kitchen')" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center space-x-2 transition-transform transform hover:scale-105"><span>Inventory Out - Base Kitchen</span></button>
            </div>
        </div>

        <!-- Verification Screen -->
        <div id="verificationScreen" class="hidden">
            <h2 id="verificationTitle" class="text-2xl font-bold mb-4">Review & Correct Data</h2>
            <img id="previewImage" class="max-w-full mx-auto rounded-lg mb-4 max-h-40 object-contain">
            
            <div id="editableTableContainer" class="mt-4 text-left editable-table-container">
                <!-- Table will be generated by JavaScript here -->
            </div>
            
            <div class="mt-6 flex space-x-2">
                <button onclick="goBack()" class="w-full bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-3 px-4 rounded-lg">Back</button>
                <button onclick="saveData()" id="confirmBtn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg">Confirm & Save</button>
            </div>
        </div>
        
        <input type="file" id="imageFile" accept="image/*" class="hidden">
        <div id="loadingSpinner" class="hidden fixed inset-0 bg-white bg-opacity-75 flex items-center justify-center z-50">
            <div class="spinner"></div><p id="loadingText" class="ml-4 text-lg font-semibold text-gray-700">Processing...</p>
        </div>
        <div id="toast"></div>
    </div>

<script>
    const apiKey = ""; // API Key for Gemini is provided at runtime in the environment
    const apiUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent';
    let currentSheetName = '';
    const homeScreen = document.getElementById('homeScreen');
    const verificationScreen = document.getElementById('verificationScreen');
    const verificationTitle = document.getElementById('verificationTitle');
    const previewImage = document.getElementById('previewImage');
    const imageFileInput = document.getElementById('imageFile');
    const loadingSpinner = document.getElementById('loadingSpinner');
    const loadingText = document.getElementById('loadingText');
    const tableContainer = document.getElementById('editableTableContainer');
    const confirmBtn = document.getElementById('confirmBtn');
    const toast = document.getElementById('toast');

    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/sw.js').catch(err => console.error('SW registration failed:', err));
        });
    }

    // --- Utility Functions ---

    // Function to convert File object to Base64 string for the Gemini API
    function fileToBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result.split(',')[1]);
            reader.onerror = error => reject(error);
            reader.readAsDataURL(file);
        });
    }

    async function fetchWithRetry(url, options, maxRetries = 3) {
        // Required for reliable network communication, especially with the AI API
        for (let i = 0; i < maxRetries; i++) {
            try {
                const response = await fetch(url, options);
                // Check if the status is a success (2xx) or a defined error that isn't rate-limiting (429)
                if (response.ok || response.status !== 429) { 
                    return response;
                }
                // Implement exponential backoff for 429 (rate limiting)
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            } catch (error) {
                if (i === maxRetries - 1) throw error;
                // Retry on network errors
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        throw new Error("API request failed after multiple retries.");
    }

    function showToast(message, isError = false) {
        toast.textContent = message;
        toast.className = "show";
        toast.style.backgroundColor = isError ? "#ef4444" : "#333";
        setTimeout(() => { toast.className = toast.className.replace("show", ""); }, 3000);
    }

    function showVerificationScreen(file, title) {
        verificationTitle.textContent = title;
        previewImage.src = URL.createObjectURL(file);
        homeScreen.classList.add('hidden');
        verificationScreen.classList.remove('hidden');
        tableContainer.innerHTML = '<p class="text-center text-gray-500">Extracting data...</p>';
        confirmBtn.disabled = true;
        
        // Use the Gemini Agent function for processing
        agentOcr(file, currentSheetName);
    }

    function goBack() {
        verificationScreen.classList.add('hidden');
        homeScreen.classList.remove('hidden');
        currentSheetName = '';
        // Clear the file input so the same file can be re-uploaded
        imageFileInput.value = '';
    }

    function showImageSourceDialog(title, sheetName) {
        currentSheetName = sheetName;
        imageFileInput.click();
    }
    
    imageFileInput.onchange = (e) => {
        if (e.target.files && e.target.files[0]) {
            showVerificationScreen(e.target.files[0], `Review for ${currentSheetName}`);
        }
    };

    function renderEditableTable(columns, rows) {
        tableContainer.innerHTML = ''; 
        if (!rows || rows.length === 0) {
            tableContainer.innerHTML = '<p class="text-center text-gray-500">No items were found. Please check the image.</p>';
            return;
        }
        
        // Use the first element of the columns array for headers
        const headers = columns.flat();

        const table = document.createElement('table');
        table.className = 'w-full editable-table';
        
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        headers.forEach(headerText => {
            const th = document.createElement('th');
            th.textContent = headerText;
            th.className = 'px-6 py-3 text-left text-xs font-bold uppercase tracking-wider';
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        rows.forEach(rowData => {
            const tr = document.createElement('tr');
            rowData.forEach(cellData => {
                const td = document.createElement('td');
                const input = document.createElement('input');
                input.type = 'text';
                input.value = cellData || '';
                td.appendChild(input);
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        tableContainer.appendChild(table);
    }


    // --- AGENT FUNCTION: Uses Gemini API for image-to-data extraction (OCR replacement) ---
    async function agentOcr(file, sheetName) {
        loadingText.textContent = "Extracting & Parsing with AI...";
        loadingSpinner.classList.remove('hidden');
        
        try {
            const base64Data = await fileToBase64(file);
            const prompt = `You are a data extraction expert. The user has provided an image of a document related to restaurant costs, categorized as '${sheetName}'. Your task is to accurately extract the data into a structured JSON format. 
            
            1. Identify the key columns (headers) such as 'Item Name', 'Quantity', 'Unit', and 'Price/Cost'.
            2. Extract all corresponding rows of data, including any serial numbers.
            3. Ensure all extracted values, including numbers, are represented as strings.
            4. Provide the output strictly in the requested JSON schema.
            
            Example prompt to yourself: Extract the columns like 'S. no.', 'Item Name', 'Quantity', 'Unit', 'Price' and their corresponding values from the image.`;

            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [
                            { text: prompt },
                            {
                                inlineData: {
                                    mimeType: file.type || "image/jpeg",
                                    data: base64Data
                                }
                            }
                        ]
                    }
                ],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "columns": {
                                "type": "ARRAY",
                                "description": "The header row of the table, typically an array containing a single array of strings (e.g., [['S. no.', 'Item', 'Quantity', 'Unit']]).",
                                "items": {
                                    "type": "ARRAY",
                                    "items": { "type": "STRING" }
                                }
                            },
                            "rows": {
                                "type": "ARRAY",
                                "description": "An array of arrays, where each inner array represents a row of extracted data.",
                                "items": {
                                    "type": "ARRAY",
                                    "items": { "type": "STRING" }
                                }
                            }
                        },
                        "required": ["columns", "rows"]
                    }
                }
            };
            
            const response = await fetchWithRetry(`${apiUrl}?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            // Handle non-200 responses if the AI API server returns them
            if (!response.ok) {
                 const errorBody = await response.json();
                 const errorMessage = errorBody.error?.message || `AI API returned status ${response.status}.`;
                 throw new Error(`AI API Error: ${errorMessage}`);
            }

            const result = await response.json();
            
            const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;

            if (!jsonText) {
                 throw new Error("AI did not return a valid structured response.");
            }
            
            // The AI provides the JSON as a string, so we must parse it.
            const parsedResult = JSON.parse(jsonText);

            if (!parsedResult.columns || !parsedResult.rows) {
                throw new Error("Received invalid data structure from the AI.");
            }

            console.log("Data received from OCR API:", JSON.stringify(parsedResult, null, 2));
            renderEditableTable(parsedResult.columns, parsedResult.rows);

        } catch (error) {
            console.error('OCR Agent error:', error);
            // Display the detailed error message
            tableContainer.innerHTML = `<p class="text-center text-red-500">Error: Extraction failed. Please try a clearer image or ensure a valid document type was selected. Details: ${error.message}</p>`;
            showToast(`Error extracting data: ${error.message}`, true);
        } finally {
            loadingSpinner.classList.add('hidden');
            confirmBtn.disabled = false;
        }
    }


    // --- AGENT FUNCTION: Simulates the /api/save endpoint ---
    async function agentSave(sheetName, data) {
        // This is a simulation for demonstration since we are not connecting to a real sheet.
        console.log(`Simulating save to sheet: ${sheetName}`);
        console.log("Data to save:", data);

        // Simulate a network delay
        await new Promise(resolve => setTimeout(resolve, 1500)); 

        return {
            message: `Data successfully saved for ${sheetName} with ${data.length} rows.`
        };
    }
    // --- End AGENT Functions ---


    // --- Core Save Logic (Uses agentSave) ---
    async function saveData() {
        const rows = tableContainer.querySelectorAll('tbody tr');
        if (rows.length === 0) {
            showToast("Nothing to save.", true);
            return;
        }

        const dataToSend = [];
        rows.forEach(row => {
            const rowData = [];
            row.querySelectorAll('input').forEach(input => {
                rowData.push(input.value);
            });
            dataToSend.push(rowData);
        });

        loadingText.textContent = "Saving Data...";
        loadingSpinner.classList.remove('hidden');
        confirmBtn.disabled = true;

        try {
            // CALL THE AGENT FUNCTION DIRECTLY
            const result = await agentSave(currentSheetName, dataToSend);
            
            showToast(result.message || `Success! Data saved to ${currentSheetName}.`);
            goBack();

        } catch (error) {
            console.error('Save error:', error);
            showToast(`Save Error: ${error.message}`, true);
        } finally {
            loadingSpinner.classList.add('hidden');
            confirmBtn.disabled = false;
        }
    }
</script>
</body>
</html>
